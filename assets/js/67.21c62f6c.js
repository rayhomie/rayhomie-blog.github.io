(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{412:function(t,_,a){"use strict";a.r(_);var e=a(42),r=Object(e.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react渲染和更新机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react渲染和更新机制"}},[t._v("#")]),t._v(" React"),a("a",{attrs:{href:"https://mp.weixin.qq.com/s/NlmtgWcvnW-IRJ_CcRsb5A",target:"_blank",rel:"noopener noreferrer"}},[t._v("渲染"),a("OutboundLink")],1),t._v("和"),a("a",{attrs:{href:"https://mp.weixin.qq.com/s/He3DoAObZafpTN2Yp09N_g",target:"_blank",rel:"noopener noreferrer"}},[t._v("更新机制"),a("OutboundLink")],1)]),t._v(" "),a("h2",{attrs:{id:"【jsx原理剖析】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【jsx原理剖析】"}},[t._v("#")]),t._v(" 【JSX原理剖析】")]),t._v(" "),a("h3",{attrs:{id:"_1】jsx转换本质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1】jsx转换本质"}},[t._v("#")]),t._v(" 1】JSX转换本质")]),t._v(" "),a("p",[t._v("实际上，JSX 仅仅只是 "),a("code",[t._v("React.createElement(component, props, ...children)")]),t._v(" 函数的"),a("strong",[t._v("语法糖")]),t._v("。")]),t._v(" "),a("ul",[a("li",[t._v("所有的 JSX 最终都会被转换成"),a("code",[t._v("React.createElement")]),t._v("的函数被调用。")])]),t._v(" "),a("p",[a("code",[t._v("React.createElement")]),t._v("源码如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200714163846378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTIyMTAzNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),t._v(" "),a("h3",{attrs:{id:"_2】虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2】虚拟dom"}},[t._v("#")]),t._v(" 2】虚拟DOM")]),t._v(" "),a("ul",[a("li",[t._v("React利用ReactElement对象组成了一个JavaScript的对象树；")]),t._v(" "),a("li",[t._v("JavaScript的对象树就是大名鼎鼎的虚拟DOM（Virtual DOM）；")]),t._v(" "),a("li",[t._v("整体的转换过程如下：")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200714180322210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTIyMTAzNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),t._v(" "),a("h3",{attrs:{id:"_3】为什么采用虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3】为什么采用虚拟dom"}},[t._v("#")]),t._v(" 3】为什么采用虚拟DOM")]),t._v(" "),a("p",[t._v("为什么要采用虚拟DOM，而不是直接修改真实的DOM呢？")]),t._v(" "),a("ul",[a("li",[t._v("很难跟踪状态发生的改变：原有的开发模式，我们很难跟踪到状态发生的改变，不方便针对我们应用程序进行调试；")]),t._v(" "),a("li",[a("strong",[t._v("操作真实DOM性能较低")]),t._v("：传统的开发模式会进行频繁的DOM操作，而这一的做法性能非常的低；\n"),a("ul",[a("li",[t._v("首先，document.createElement本身创建出来的就是一个非常复杂的对象；")]),t._v(" "),a("li",[t._v("其次，DOM操作会引起浏览器的"),a("strong",[t._v("回流和重绘")]),t._v("，所以在开发中应该避免频繁的DOM操作；")])])])]),t._v(" "),a("p",[a("strong",[t._v("虚拟DOM帮助我们从命令式编程转到了声明式编程的模式")])]),t._v(" "),a("p",[t._v("React官方的说法：Virtual DOM 是一种"),a("strong",[t._v("编程理念")]),t._v("。")]),t._v(" "),a("p",[t._v("在这个理念中，UI以一种理想化或者说虚拟化的方式保存在内存中，并且它是一个相对简单的JavaScript对象，我们可以通过ReactDOM.render让 "),a("strong",[t._v("虚拟DOM")]),t._v(" 和  "),a("strong",[t._v("真实DOM")]),t._v(" 同步起来，这个过程中叫做协调（Reconciliation）；")]),t._v(" "),a("p",[t._v("这种编程的方式赋予了React声明式的API：你只需要告诉React希望让UI是什么状态，React来确保DOM和这些状态是匹配的。")]),t._v(" "),a("p",[t._v("你不需要直接进行DOM操作，只可以从手动更改DOM、属性操作、事件处理中解放出来；")]),t._v(" "),a("h2",{attrs:{id:"【react更新机制】"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【react更新机制】"}},[t._v("#")]),t._v(" 【React更新机制】")]),t._v(" "),a("p",[t._v("React渲染流程：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200714182034469.png",alt:"在这里插入图片描述"}})]),t._v(" "),a("p",[t._v("React的更新流程：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200714182226727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTIyMTAzNg==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),t._v(" "),a("p",[t._v("React在"),a("strong",[t._v("props或state发生改变")]),t._v("时，会"),a("strong",[t._v("调用React的render方法")]),t._v("，会"),a("strong",[t._v("创建一颗不同的树")]),t._v("。")]),t._v(" "),a("p",[t._v("React需要基于这两颗不同的树之间的"),a("strong",[t._v("差别")]),t._v("（diff算法）来判断如何有效的更新UI：")]),t._v(" "),a("ul",[a("li",[t._v("如果一棵树参考另外一棵树进行完全比较更新，那么即使是最先进的算法，该算法的复杂程度为 O(n 3 )，其中 n 是树中元素的数量；")]),t._v(" "),a("li",[t._v("如果在 React 中使用了该算法，那么展示 1000 个元素所需要执行的计算量将在十亿的量级范围；")]),t._v(" "),a("li",[t._v("这个开销太过昂贵了，React的更新性能会变得非常低效；")])]),t._v(" "),a("p",[t._v("于是，React对这个算法进行了优化，将其优化成了O(n)，如何优化的呢？")]),t._v(" "),a("ul",[a("li",[t._v("同层节点之间相互比较，不会垮节点比较；")]),t._v(" "),a("li",[t._v("发现不同直接跳出比较。")]),t._v(" "),a("li",[t._v("不同类型的节点，产生不同的树结构；")]),t._v(" "),a("li",[t._v("开发中，可以通过key来指定哪些节点在不同的渲染下保持稳定；")])])])}),[],!1,null,null,null);_.default=r.exports}}]);